
}
/* Minimal global styles (no Tailwind). */

:root {
  color-scheme: light;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji",
    "Segoe UI Emoji";
  line-height: 1.4;
}

body {
  margin: 0;
  background: #0b1220;
  color: #e7eefc;
}

a {
  color: inherit;
}

.container {
  max-width: 980px;
  margin: 0 auto;
  padding: 24px;
}

.card {
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 12px;
  padding: 16px;
}

.row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.button {
  appearance: none;
  border: 1px solid rgba(255, 255, 255, 0.25);
  background: rgba(255, 255, 255, 0.08);
  color: #e7eefc;
  border-radius: 10px;
  padding: 10px 12px;
  cursor: pointer;
}

.button:hover {
  background: rgba(255, 255, 255, 0.14);
}

.badge {
  display: inline-flex;
  align-items: center;
  padding: 2px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  background: rgba(255, 255, 255, 0.08);
  font-size: 12px;
}


/* ================================
   Maze-Cog Icon Theme (Global)
   ================================ */

/* Base icon style */
.app-icon {
  width: 42px;
  height: 42px;
  fill: currentColor;
  color: #1a1a1a;

  transition:
    transform 160ms ease,
    filter 160ms ease,
    opacity 120ms ease;
}

/* Unselected / idle */
.app-icon.idle {
  opacity: 0.45;
  transform: scale(0.96);
}

/* Hover (desktop only, harmless on mobile) */
.app-icon:hover {
  opacity: 0.85;
  transform: scale(1.04);
}

/* Selected / active */
.app-icon.active {
  opacity: 1;
  transform: scale(1.12) translateY(-1px);
  filter:
    drop-shadow(0 2px 6px rgba(0, 0, 0, 0.25))
    drop-shadow(0 0 8px rgba(0, 0, 0, 0.15));
}

/* Pressed (tap feedback) */
.app-icon:active {
  transform: scale(1.06);
  filter:
    drop-shadow(0 1px 4px rgba(0, 0, 0, 0.35));
}

/* Disabled / locked */
.app-icon.disabled {
  opacity: 0.25;
  filter: none;
  transform: none;
  pointer-events: none;
}

/* Optional accent color for results */
.app-icon.result {
  color: #0f4c81; /* muted steel blue */
}

/* Urgent / high-confidence result */
.app-icon.urgent {
  color: #8a1f11; /* deep red */
  filter:
    drop-shadow(0 0 6px rgba(138, 31, 17, 0.4));
}


* 

/* =========================
   RESULTS PANEL – FINAL
   ========================= */

.results-panel {
  border-radius: 14px;
  padding: 16px 18px;
  margin-top: 12px;
  background: linear-gradient(
    180deg,
    rgba(20, 20, 22, 0.96),
    rgba(14, 14, 16, 0.98)
  );
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow:
    0 10px 24px rgba(0, 0, 0, 0.45),
    inset 0 1px 0 rgba(255, 255, 255, 0.04);
}

/* Primary diagnosis emphasis */
.results-panel .primary-diagnosis {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 1.05rem;
  font-weight: 600;
  color: #ffffff;
}

/* Target / component icon */
.results-panel .primary-diagnosis svg {
  width: 22px;
  height: 22px;
  stroke-width: 2.2;
  color: #ff5a3c;
  filter: drop-shadow(0 0 6px rgba(255, 90, 60, 0.35));
}

/* Confidence / urgency badge */
.results-panel .confidence-badge {
  margin-left: auto;
  padding: 4px 10px;
  border-radius: 999px;
  font-size: 0.72rem;
  letter-spacing: 0.04em;
  background: rgba(255, 90, 60, 0.12);
  color: #ffb3a6;
  border: 1px solid rgba(255, 90, 60, 0.25);
}

/* Secondary hypotheses */
.results-panel .secondary-diagnosis {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(255, 255, 255, 0.06);
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.7);
}

/* Section headers inside results */
.results-panel h4 {
  margin: 14px 0 6px;
  font-size: 0.75rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.55);
}

/* Lists (what to check, notes, etc.) */
.results-panel ul {
  padding-left: 18px;
  margin: 6px 0 0;
}

.results-panel li {
  margin-bottom: 6px;
  line-height: 1.45;
}

/* Subtle entry animation */
.results-panel {
  animation: resultsFadeIn 220ms ease-out;
}

@keyframes resultsFadeIn {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}/**

Maze-Cog Icon “Master SVG Rule”

Generates a cohesive set of icons that match your spec:

Outer ring: cog/track edge, thick, irregular teeth, slight asymmetry (never mirrored)


Interior: 1–2 loop arcs, no tight corridors, center slightly off-center


Line weight: primary heavy, secondary thinner but bold, thickness biased near ~6 o’clock


Psych read: hints of eye/mouth/motion (never literal)


Usage:

node gen.js > icons.svg

or paste into a browser console and run downloadSvgSet().
*/


// ---------- utilities ----------
function mulberry32(seed) {
let t = seed >>> 0;
return function () {
t += 0x6D2B79F5;
let x = Math.imul(t ^ (t >>> 15), 1 | t);
x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
};
}
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function degToRad(d) { return (d * Math.PI) / 180; }
function polar(cx, cy, r, angDeg) {
const a = degToRad(angDeg);
return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
}
function arcPath(cx, cy, r, a0, a1) {
// SVG arc (sweep = 1)
const p0 = polar(cx, cy, r, a0);
const p1 = polar(cx, cy, r, a1);
const large = Math.abs(((a1 - a0) % 360 + 360) % 360) > 180 ? 1 : 0;
return M ${p0.x.toFixed(3)} ${p0.y.toFixed(3)} A ${r.toFixed(3)} ${r.toFixed(3)} 0 ${large} 1 ${p1.x.toFixed(3)} ${p1.y.toFixed(3)};
}
function randBetween(rng, a, b) { return lerp(a, b, rng()); }
function pick(rng, arr) { return arr[Math.floor(rng() * arr.length)]; }

// ---------- core “rule” ----------
function generateIcon(seed, opts = {}) {
const rng = mulberry32(seed);

// Canvas
const size = opts.size ?? 256;      // px
const vb = 100;                     // viewBox units
const cx = 50, cy = 50;

// Style controls (tweak here)
const outerR = 46;                  // outer radius
const ringW  = 14;                  // ring thickness (maze border body)
const toothCount = 22 + Math.floor(rng() * 6); // 22–27
const toothDepth = 4.0 + rng() * 2.0;          // 4–6
const toothWidthDegBase = 7.0 + rng() * 2.0;   // base angular tooth width
const jitterDeg = 1.2 + rng() * 1.4;           // tooth irregularity

// Slight asymmetry (never mirrored): offset center a bit
const ox = randBetween(rng, -2.8, 2.8);
const oy = randBetween(rng, -2.8, 2.8);

// Depth / “pressing from behind”: thickness bias near 6 o’clock
const biasAngle = 270 + randBetween(rng, -14, 14); // ~6 o’clock
const altBias = rng() < 0.18 ? 315 + randBetween(rng, -10, 10) : null; // ~4 o’clock (rare)
const biasStrength = 0.55 + rng() * 0.35; // 0.55–0.90

// Maze rings (1–2 loops max)
const loopCount = rng() < 0.55 ? 1 : 2;
const ringRadii = loopCount === 1
? [outerR - ringW - 8]
: [outerR - ringW - 6, outerR - ringW - 18];

// Openings / breaks (no tight corridors)
// Use 2–4 breaks total across rings, with one dominant “entry” near 6 o’clock.
const entryAngle = biasAngle + randBetween(rng, -10, 10);
const breakAngles = [entryAngle];
const extraBreaks = 1 + Math.floor(rng() * 3); // 1–3 more
for (let i = 0; i < extraBreaks; i++) {
let a = randBetween(rng, 0, 360);
// avoid clustering too close to entry
if (Math.abs(((a - entryAngle + 540) % 360) - 180) < 30) a = (a + 60) % 360;
breakAngles.push(a);
}

// Tiny “voids/nicks” (optional)
const nickCount = rng() < 0.45 ? 0 : (rng() < 0.85 ? 1 : 2);
const nicks = [];
for (let i = 0; i < nickCount; i++) {
nicks.push({
a: randBetween(rng, 0, 360),
r: randBetween(rng, outerR - 10, outerR - 3),
w: randBetween(rng, 1.6, 2.8),
});
}

// Stroke thickness model (primary heavy, secondary thinner)
// We’ll create thick “walls” as filled paths (strokes with round joins).
function thicknessAt(angleDeg, base, extra) {
const ang = ((angleDeg % 360) + 360) % 360;
const d1 = Math.cos(degToRad(ang - biasAngle));
const b1 = clamp((d1 + 1) / 2, 0, 1); // 0..1
let b = b1;
if (altBias != null) {
const d2 = Math.cos(degToRad(ang - altBias));
const b2 = clamp((d2 + 1) / 2, 0, 1);
b = Math.max(b, 0.85 * b2);
}
return base + extra * Math.pow(b, 1.6) * biasStrength;
}

// ---------- build outer gear/track ring ----------
// Strategy: ring body = donut (outer circle minus inner circle).
// Teeth = small rectangular-ish bumps along circumference (as arcs expanded outward).
// For simplicity & robustness, approximate teeth using short arc segments on outer edge.
const outerCircle = M ${cx + outerR} ${cy}   A ${outerR} ${outerR} 0 1 1 ${cx - outerR} ${cy}   A ${outerR} ${outerR} 0 1 1 ${cx + outerR} ${cy} Z;

const innerR = outerR - ringW;
const innerCircle = M ${cx + innerR} ${cy}   A ${innerR} ${innerR} 0 1 0 ${cx - innerR} ${cy}   A ${innerR} ${innerR} 0 1 0 ${cx + innerR} ${cy} Z;

// Teeth as separate paths (filled) around the outside
const teeth = [];
const step = 360 / toothCount;
for (let i = 0; i < toothCount; i++) {
const aMid = i * step + randBetween(rng, -jitterDeg, jitterDeg);
const wDeg = toothWidthDegBase + randBetween(rng, -1.2, 1.0);
const a0 = aMid - wDeg / 2;
const a1 = aMid + wDeg / 2;

// slight tooth-depth modulation (irregular)  
const depth = toothDepth * (0.75 + rng() * 0.6);  
const r0 = outerR;  
const r1 = outerR + depth;  

// Build a “tooth” as a closed shape between outer arc at r1 and inner arc at r0  
const pA = polar(cx, cy, r0, a0);  
const pB = polar(cx, cy, r0, a1);  
const pC = polar(cx, cy, r1, a1);  
const pD = polar(cx, cy, r1, a0);  

const large = (wDeg > 180) ? 1 : 0;  
const tooth = [  
  `M ${pA.x.toFixed(3)} ${pA.y.toFixed(3)}`,  
  `A ${r0.toFixed(3)} ${r0.toFixed(3)} 0 ${large} 1 ${pB.x.toFixed(3)} ${pB.y.toFixed(3)}`,  
  `L ${pC.x.toFixed(3)} ${pC.y.toFixed(3)}`,  
  `A ${r1.toFixed(3)} ${r1.toFixed(3)} 0 ${large} 0 ${pD.x.toFixed(3)} ${pD.y.toFixed(3)}`,  
  `Z`,  
].join(" ");  
teeth.push(`<path d="${tooth}" fill="#000"/>`);

}

// ---------- build interior “maze” as thick strokes ----------
// We’ll draw 1–2 rings of arc segments with intentional gaps (breaks),
// plus 1–2 “spokes” (connectors) to create the looped maze feel.
const mazePaths = [];

function addRing(r, ringIndex) {
// choose 2–3 arc segments (no tight corridors)
const segCount = 2 + Math.floor(rng() * 2); // 2–3
// choose segment spans
const spans = [];
let start = randBetween(rng, 0, 360);
for (let s = 0; s < segCount; s++) {
const span = randBetween(rng, 75, 145); // big chunks = simple maze
spans.push([start, start + span]);
start += span + randBetween(rng, 25, 70);
}

// carve gaps near break angles (including entry near 6 o’clock)  
for (const [aS, aE] of spans) {  
  // split by removing any portion close to a break angle  
  let pieces = [[aS, aE]];  
  for (const b of breakAngles) {  
    const gap = randBetween(rng, 18, 34) * (ringIndex === 0 ? 1.1 : 0.9);  
    const b0 = b - gap / 2;  
    const b1 = b + gap / 2;  

    const next = [];  
    for (const [p0, p1] of pieces) {  
      // if gap intersects, cut it out  
      // normalize by checking overlap in angle space (approx; sufficient for this use)  
      if (b1 < p0 || b0 > p1) { next.push([p0, p1]); continue; }  
      if (b0 > p0) next.push([p0, b0]);  
      if (b1 < p1) next.push([b1, p1]);  
    }  
    pieces = next;  
  }  

  for (const [p0, p1] of pieces) {  
    const mid = (p0 + p1) / 2;  
    const w = thicknessAt(mid, 10.5, 7.5) * (ringIndex === 0 ? 1.00 : 0.86); // heavy primary  
    const d = arcPath(cx + ox, cy + oy, r, p0, p1);  
    mazePaths.push(`<path d="${d}" fill="none" stroke="#000" stroke-width="${w.toFixed(2)}" stroke-linecap="round" stroke-linejoin="round"/>`);  
  }  
}

}

ringRadii.forEach((r, idx) => addRing(r, idx));

// Add 1–2 connectors (secondary strokes)
const connectorCount = 1 + (rng() < 0.45 ? 0 : 1); // 1–2
for (let i = 0; i < connectorCount; i++) {
const a = (i === 0 ? entryAngle + randBetween(rng, -18, 18) : randBetween(rng, 0, 360));
const r0 = ringRadii[ringRadii.length - 1] - randBetween(rng, 5, 10);
const r1 = ringRadii[0] + randBetween(rng, 3, 9);
const p0 = polar(cx + ox, cy + oy, r0, a);
const p1 = polar(cx + ox, cy + oy, r1, a + randBetween(rng, -10, 10));

const w = thicknessAt(a, 7.8, 5.6) * 0.82; // secondary thinner but bold  
const d = `M ${p0.x.toFixed(3)} ${p0.y.toFixed(3)} L ${p1.x.toFixed(3)} ${p1.y.toFixed(3)}`;  
mazePaths.push(`<path d="${d}" fill="none" stroke="#000" stroke-width="${w.toFixed(2)}" stroke-linecap="round" stroke-linejoin="round"/>`);

}

// Center mass (slightly off-center “eye/mouth-ish” blob)
const centerR = randBetween(rng, 6.5, 10.5);
const centerW = thicknessAt(270, 10.8, 6.8) * 0.55;
const center = <ellipse cx="${(cx + ox + randBetween(rng, -1.2, 1.2)).toFixed(2)}"   cy="${(cy + oy + randBetween(rng, -1.2, 1.2)).toFixed(2)}"   rx="${centerR.toFixed(2)}"   ry="${(centerR * randBetween(rng, 0.70, 0.92)).toFixed(2)}"   fill="#000"   transform="rotate(${randBetween(rng, -18, 18).toFixed(2)} ${(cx+ox).toFixed(2)} ${(cy+oy).toFixed(2)})" />;

// Nicks/voids (tiny cutouts)
const nickPaths = nicks.map(n => {
const p = polar(cx + ox, cy + oy, n.r, n.a);
return <circle cx="${p.x.toFixed(2)}" cy="${p.y.toFixed(2)}" r="${n.w.toFixed(2)}" fill="#fff"/>;
}).join("");

// Assemble with a clip to keep all interior within ring
// (use the donut as a mask and then draw maze on top; for “icon” look, maze + ring are black on white)
const svg = `
<svg width="${size}" height="${size}" viewBox="0 0 ${vb} ${vb}" xmlns="http://www.w3.org/2000/svg">
<defs>
<mask id="donutMask-${seed}">
<rect width="100" height="100" fill="#000"/>
<path d="${outerCircle}" fill="#fff"/>
<path d="${innerCircle}" fill="#000"/>
</mask>
<clipPath id="innerClip-${seed}">
<circle cx="${cx}" cy="${cy}" r="${innerR - 1.2}" />
</clipPath>
</defs>

  <!-- white background -->    <rect width="100" height="100" fill="#fff"/>    <!-- gear ring body -->    <g>  
    <path d="${outerCircle}" fill="#000"/>  
    <path d="${innerCircle}" fill="#fff"/>  
    ${teeth.join("\n    ")}  
  </g>    <!-- interior maze (clipped inside inner area) -->    <g clip-path="url(#innerClip-${seed})">  
    ${mazePaths.join("\n    ")}  
    ${center}  
  </g>    <!-- tiny voids/nicks -->  ${nickPaths}
</svg>`.trim();

return svg;
}

// ---------- set generator ----------
function generateSetSvg({
seeds = [101, 102, 103, 104, 105, 106, 107, 108],
cols = 4,
cell = 260,
pad = 20
} = {}) {
const rows = Math.ceil(seeds.length / cols);
const width = cols * cell + (cols + 1) * pad;
const height = rows * cell + (rows + 1) * pad;

const icons = seeds.map((s, i) => {
const col = i % cols;
const row = Math.floor(i / cols);
const x = pad + col * (cell + pad);
const y = pad + row * (cell + pad);
const inner = generateIcon(s, { size: cell }).replace(/^<svg[^>]*>|</svg>$/g, "");
return <g transform="translate(${x},${y})">${inner}</g>;
}).join("\n");

return    <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">   <rect width="${width}" height="${height}" fill="#fff"/>   ${icons}   </svg>.trim();
}

// ---------- optional browser helper ----------
function downloadSvgSet() {
const svg = generateSetSvg();
const blob = new Blob([svg], { type: "image/svg+xml;charset=utf-8" });
const a = document.createElement("a");
a.href = URL.createObjectURL(blob);
a.download = "maze-cog-icons.svg";
a.click();
URL.revokeObjectURL(a.href);
}

// If running in Node:
if (typeof process !== "undefined" && process?.stdout) {
// Output one sheet of 8 icons
process.stdout.write(generateSetSvg());
}

